   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_kb,"ax",@progbits
  11               		.weak	matrix_init_kb
  13               	matrix_init_kb:
  14               	.LFB120:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** 
   3:matrix.c      **** Note for ErgoDox EZ customizers: Here be dragons!
   4:matrix.c      **** This is not a file you want to be messing with.
   5:matrix.c      **** All of the interesting stuff for you is under keymaps/ :)
   6:matrix.c      **** Love, Erez
   7:matrix.c      **** 
   8:matrix.c      **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   9:matrix.c      **** 
  10:matrix.c      **** This program is free software: you can redistribute it and/or modify
  11:matrix.c      **** it under the terms of the GNU General Public License as published by
  12:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
  13:matrix.c      **** (at your option) any later version.
  14:matrix.c      **** 
  15:matrix.c      **** This program is distributed in the hope that it will be useful,
  16:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  18:matrix.c      **** GNU General Public License for more details.
  19:matrix.c      **** 
  20:matrix.c      **** You should have received a copy of the GNU General Public License
  21:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  22:matrix.c      **** */
  23:matrix.c      **** 
  24:matrix.c      **** /*
  25:matrix.c      ****  * scan matrix
  26:matrix.c      ****  */
  27:matrix.c      **** #include <stdint.h>
  28:matrix.c      **** #include <stdbool.h>
  29:matrix.c      **** #include <avr/io.h>
  30:matrix.c      **** #include <util/delay.h>
  31:matrix.c      **** #include "action_layer.h"
  32:matrix.c      **** #include "print.h"
  33:matrix.c      **** #include "debug.h"
  34:matrix.c      **** #include "util.h"
  35:matrix.c      **** #include "matrix.h"
  36:matrix.c      **** #include "ergodox_ez.h"
  37:matrix.c      **** #include "i2cmaster.h"
  38:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
  39:matrix.c      **** #include  "timer.h"
  40:matrix.c      **** #endif
  41:matrix.c      **** 
  42:matrix.c      **** #ifndef DEBOUNCE
  43:matrix.c      **** #   define DEBOUNCE	5
  44:matrix.c      **** #endif
  45:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  46:matrix.c      **** 
  47:matrix.c      **** /* matrix state(1:on, 0:off) */
  48:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  49:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  50:matrix.c      **** 
  51:matrix.c      **** static matrix_row_t read_cols(uint8_t row);
  52:matrix.c      **** static void init_cols(void);
  53:matrix.c      **** static void unselect_rows();
  54:matrix.c      **** static void select_row(uint8_t row);
  55:matrix.c      **** 
  56:matrix.c      **** static uint8_t mcp23018_reset_loop;
  57:matrix.c      **** 
  58:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
  59:matrix.c      **** uint32_t matrix_timer;
  60:matrix.c      **** uint32_t matrix_scan_count;
  61:matrix.c      **** #endif
  62:matrix.c      **** 
  63:matrix.c      **** 
  64:matrix.c      **** __attribute__ ((weak))
  65:matrix.c      **** void * matrix_init_kb(void) {
  16               		.loc 1 65 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  66:matrix.c      **** };
  22               		.loc 1 66 0
  23 0000 0895      		ret
  24               		.cfi_endproc
  25               	.LFE120:
  27               		.section	.text.matrix_scan_kb,"ax",@progbits
  28               		.weak	matrix_scan_kb
  30               	matrix_scan_kb:
  31               	.LFB121:
  67:matrix.c      **** 
  68:matrix.c      **** __attribute__ ((weak))
  69:matrix.c      **** void * matrix_scan_kb(void) {
  32               		.loc 1 69 0
  33               		.cfi_startproc
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 0 */
  37               	.L__stack_usage = 0
  70:matrix.c      **** };
  38               		.loc 1 70 0
  39 0000 0895      		ret
  40               		.cfi_endproc
  41               	.LFE121:
  43               		.section	.text.unselect_rows,"ax",@progbits
  45               	unselect_rows:
  46               	.LFB133:
  71:matrix.c      **** 
  72:matrix.c      **** inline
  73:matrix.c      **** uint8_t matrix_rows(void)
  74:matrix.c      **** {
  75:matrix.c      ****     return MATRIX_ROWS;
  76:matrix.c      **** }
  77:matrix.c      **** 
  78:matrix.c      **** inline
  79:matrix.c      **** uint8_t matrix_cols(void)
  80:matrix.c      **** {
  81:matrix.c      ****     return MATRIX_COLS;
  82:matrix.c      **** }
  83:matrix.c      **** 
  84:matrix.c      **** void matrix_init(void)
  85:matrix.c      **** {
  86:matrix.c      ****     // initialize row and col
  87:matrix.c      **** 
  88:matrix.c      ****     mcp23018_status = init_mcp23018();
  89:matrix.c      **** 
  90:matrix.c      **** 
  91:matrix.c      ****     unselect_rows();
  92:matrix.c      ****     init_cols();
  93:matrix.c      **** 
  94:matrix.c      ****     // initialize matrix state: all keys off
  95:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  96:matrix.c      ****         matrix[i] = 0;
  97:matrix.c      ****         matrix_debouncing[i] = 0;
  98:matrix.c      ****     }
  99:matrix.c      **** 
 100:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
 101:matrix.c      ****     matrix_timer = timer_read32();
 102:matrix.c      ****     matrix_scan_count = 0;
 103:matrix.c      **** #endif
 104:matrix.c      **** 
 105:matrix.c      ****     if (matrix_init_kb) {
 106:matrix.c      ****         (*matrix_init_kb)();
 107:matrix.c      ****     }
 108:matrix.c      **** 
 109:matrix.c      **** }
 110:matrix.c      **** 
 111:matrix.c      **** uint8_t matrix_scan(void)
 112:matrix.c      **** {
 113:matrix.c      ****     if (mcp23018_status) { // if there was an error
 114:matrix.c      ****         if (++mcp23018_reset_loop == 0) {
 115:matrix.c      ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 116:matrix.c      ****             // this will be approx bit more frequent than once per second
 117:matrix.c      ****             print("trying to reset mcp23018\n");
 118:matrix.c      ****             mcp23018_status = init_mcp23018();
 119:matrix.c      ****             if (mcp23018_status) {
 120:matrix.c      ****                 print("left side not responding\n");
 121:matrix.c      ****             } else {
 122:matrix.c      ****                 print("left side attached\n");
 123:matrix.c      ****                 ergodox_blink_all_leds();
 124:matrix.c      ****             }
 125:matrix.c      ****         }
 126:matrix.c      ****     }
 127:matrix.c      **** 
 128:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
 129:matrix.c      ****     matrix_scan_count++;
 130:matrix.c      **** 
 131:matrix.c      ****     uint32_t timer_now = timer_read32();
 132:matrix.c      ****     if (TIMER_DIFF_32(timer_now, matrix_timer)>1000) {
 133:matrix.c      ****         print("matrix scan frequency: ");
 134:matrix.c      ****         pdec(matrix_scan_count);
 135:matrix.c      ****         print("\n");
 136:matrix.c      **** 
 137:matrix.c      ****         matrix_timer = timer_now;
 138:matrix.c      ****         matrix_scan_count = 0;
 139:matrix.c      ****     }
 140:matrix.c      **** #endif
 141:matrix.c      **** 
 142:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 143:matrix.c      ****         select_row(i);
 144:matrix.c      ****         matrix_row_t cols = read_cols(i);
 145:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 146:matrix.c      ****             matrix_debouncing[i] = cols;
 147:matrix.c      ****             if (debouncing) {
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 149:matrix.c      ****             }
 150:matrix.c      ****             debouncing = DEBOUNCE;
 151:matrix.c      ****         }
 152:matrix.c      ****         unselect_rows();
 153:matrix.c      ****     }
 154:matrix.c      **** 
 155:matrix.c      ****     if (debouncing) {
 156:matrix.c      ****         if (--debouncing) {
 157:matrix.c      ****             _delay_ms(1);
 158:matrix.c      ****         } else {
 159:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 160:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 161:matrix.c      ****             }
 162:matrix.c      ****         }
 163:matrix.c      ****     }
 164:matrix.c      **** 
 165:matrix.c      **** 
 166:matrix.c      ****     if (matrix_scan_kb) {
 167:matrix.c      ****         (*matrix_scan_kb)();
 168:matrix.c      ****     }
 169:matrix.c      **** 
 170:matrix.c      ****     return 1;
 171:matrix.c      **** }
 172:matrix.c      **** 
 173:matrix.c      **** bool matrix_is_modified(void)
 174:matrix.c      **** {
 175:matrix.c      ****     if (debouncing) return false;
 176:matrix.c      ****     return true;
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** inline
 180:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 181:matrix.c      **** {
 182:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 183:matrix.c      **** }
 184:matrix.c      **** 
 185:matrix.c      **** inline
 186:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 187:matrix.c      **** {
 188:matrix.c      ****     return matrix[row];
 189:matrix.c      **** }
 190:matrix.c      **** 
 191:matrix.c      **** void matrix_print(void)
 192:matrix.c      **** {
 193:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 194:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 195:matrix.c      ****         phex(row); print(": ");
 196:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 197:matrix.c      ****         print("\n");
 198:matrix.c      ****     }
 199:matrix.c      **** }
 200:matrix.c      **** 
 201:matrix.c      **** uint8_t matrix_key_count(void)
 202:matrix.c      **** {
 203:matrix.c      ****     uint8_t count = 0;
 204:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 205:matrix.c      ****         count += bitpop16(matrix[i]);
 206:matrix.c      ****     }
 207:matrix.c      ****     return count;
 208:matrix.c      **** }
 209:matrix.c      **** 
 210:matrix.c      **** /* Column pin configuration
 211:matrix.c      ****  *
 212:matrix.c      ****  * Teensy
 213:matrix.c      ****  * col: 0   1   2   3   4   5
 214:matrix.c      ****  * pin: F0  F1  F4  F5  F6  F7
 215:matrix.c      ****  *
 216:matrix.c      ****  * MCP23018
 217:matrix.c      ****  * col: 0   1   2   3   4   5
 218:matrix.c      ****  * pin: B5  B4  B3  B2  B1  B0
 219:matrix.c      ****  */
 220:matrix.c      **** static void  init_cols(void)
 221:matrix.c      **** {
 222:matrix.c      ****     // init on mcp23018
 223:matrix.c      ****     // not needed, already done as part of init_mcp23018()
 224:matrix.c      **** 
 225:matrix.c      ****     // init on teensy
 226:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 227:matrix.c      ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 228:matrix.c      ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 229:matrix.c      **** }
 230:matrix.c      **** 
 231:matrix.c      **** static matrix_row_t read_cols(uint8_t row)
 232:matrix.c      **** {
 233:matrix.c      ****     if (row < 7) {
 234:matrix.c      ****         if (mcp23018_status) { // if there was an error
 235:matrix.c      ****             return 0;
 236:matrix.c      ****         } else {
 237:matrix.c      ****             uint8_t data = 0;
 238:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 239:matrix.c      ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 240:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 241:matrix.c      ****             data = i2c_readNak();
 242:matrix.c      ****             data = ~data;
 243:matrix.c      ****         out:
 244:matrix.c      ****             i2c_stop();
 245:matrix.c      ****             return data;
 246:matrix.c      ****         }
 247:matrix.c      ****     } else {
 248:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
 249:matrix.c      ****         // read from teensy
 250:matrix.c      ****         return
 251:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 252:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 253:matrix.c      ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 254:matrix.c      ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 255:matrix.c      ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 256:matrix.c      ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 257:matrix.c      ****     }
 258:matrix.c      **** }
 259:matrix.c      **** 
 260:matrix.c      **** /* Row pin configuration
 261:matrix.c      ****  *
 262:matrix.c      ****  * Teensy
 263:matrix.c      ****  * row: 7   8   9   10  11  12  13
 264:matrix.c      ****  * pin: B0  B1  B2  B3  D2  D3  C6
 265:matrix.c      ****  *
 266:matrix.c      ****  * MCP23018
 267:matrix.c      ****  * row: 0   1   2   3   4   5   6
 268:matrix.c      ****  * pin: A0  A1  A2  A3  A4  A5  A6
 269:matrix.c      ****  */
 270:matrix.c      **** static void unselect_rows(void)
 271:matrix.c      **** {
  47               		.loc 1 271 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 272:matrix.c      ****     // unselect on mcp23018
 273:matrix.c      ****     if (mcp23018_status) { // if there was an error
  53               		.loc 1 273 0
  54 0000 8091 0000 		lds r24,mcp23018_status
  55 0004 8111      		cpse r24,__zero_reg__
  56 0006 00C0      		rjmp .L4
 274:matrix.c      ****         // do nothing
 275:matrix.c      ****     } else {
 276:matrix.c      ****         // set all rows hi-Z : 1
 277:matrix.c      ****         mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  57               		.loc 1 277 0
  58 0008 80E4      		ldi r24,lo8(64)
  59 000a 0E94 0000 		call i2c_start
  60               	.LVL0:
  61 000e 8093 0000 		sts mcp23018_status,r24
  62 0012 8111      		cpse r24,__zero_reg__
  63 0014 00C0      		rjmp .L6
 278:matrix.c      ****         mcp23018_status = i2c_write(GPIOA);             if (mcp23018_status) goto out;
  64               		.loc 1 278 0
  65 0016 82E1      		ldi r24,lo8(18)
  66 0018 0E94 0000 		call i2c_write
  67               	.LVL1:
  68 001c 8093 0000 		sts mcp23018_status,r24
  69 0020 8111      		cpse r24,__zero_reg__
  70 0022 00C0      		rjmp .L6
 279:matrix.c      ****         mcp23018_status = i2c_write( 0xFF
  71               		.loc 1 279 0
  72 0024 8FEF      		ldi r24,lo8(-1)
  73 0026 0E94 0000 		call i2c_write
  74               	.LVL2:
  75 002a 8093 0000 		sts mcp23018_status,r24
  76               	.L6:
 280:matrix.c      ****                               & ~(0<<7)
 281:matrix.c      ****                           );                            if (mcp23018_status) goto out;
 282:matrix.c      ****     out:
 283:matrix.c      ****         i2c_stop();
  77               		.loc 1 283 0
  78 002e 0E94 0000 		call i2c_stop
  79               	.LVL3:
  80               	.L4:
 284:matrix.c      ****     }
 285:matrix.c      **** 
 286:matrix.c      ****     // unselect on teensy
 287:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 288:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  81               		.loc 1 288 0
  82 0032 84B1      		in r24,0x4
  83 0034 807F      		andi r24,lo8(-16)
  84 0036 84B9      		out 0x4,r24
 289:matrix.c      ****     PORTB &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  85               		.loc 1 289 0
  86 0038 85B1      		in r24,0x5
  87 003a 807F      		andi r24,lo8(-16)
  88 003c 85B9      		out 0x5,r24
 290:matrix.c      ****     DDRD  &= ~(1<<2 | 1<<3);
  89               		.loc 1 290 0
  90 003e 8AB1      		in r24,0xa
  91 0040 837F      		andi r24,lo8(-13)
  92 0042 8AB9      		out 0xa,r24
 291:matrix.c      ****     PORTD &= ~(1<<2 | 1<<3);
  93               		.loc 1 291 0
  94 0044 8BB1      		in r24,0xb
  95 0046 837F      		andi r24,lo8(-13)
  96 0048 8BB9      		out 0xb,r24
 292:matrix.c      ****     DDRC  &= ~(1<<6);
  97               		.loc 1 292 0
  98 004a 3E98      		cbi 0x7,6
 293:matrix.c      ****     PORTC &= ~(1<<6);
  99               		.loc 1 293 0
 100 004c 4698      		cbi 0x8,6
 101 004e 0895      		ret
 102               		.cfi_endproc
 103               	.LFE133:
 105               		.section	.text.matrix_rows,"ax",@progbits
 106               	.global	matrix_rows
 108               	matrix_rows:
 109               	.LFB122:
  74:matrix.c      **** {
 110               		.loc 1 74 0
 111               		.cfi_startproc
 112               	/* prologue: function */
 113               	/* frame size = 0 */
 114               	/* stack size = 0 */
 115               	.L__stack_usage = 0
  76:matrix.c      **** }
 116               		.loc 1 76 0
 117 0000 8EE0      		ldi r24,lo8(14)
 118 0002 0895      		ret
 119               		.cfi_endproc
 120               	.LFE122:
 122               		.section	.text.matrix_cols,"ax",@progbits
 123               	.global	matrix_cols
 125               	matrix_cols:
 126               	.LFB123:
  80:matrix.c      **** {
 127               		.loc 1 80 0
 128               		.cfi_startproc
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 0 */
 132               	.L__stack_usage = 0
  82:matrix.c      **** }
 133               		.loc 1 82 0
 134 0000 86E0      		ldi r24,lo8(6)
 135 0002 0895      		ret
 136               		.cfi_endproc
 137               	.LFE123:
 139               		.section	.text.matrix_init,"ax",@progbits
 140               	.global	matrix_init
 142               	matrix_init:
 143               	.LFB124:
  85:matrix.c      **** {
 144               		.loc 1 85 0
 145               		.cfi_startproc
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 0 */
 149               	.L__stack_usage = 0
  88:matrix.c      ****     mcp23018_status = init_mcp23018();
 150               		.loc 1 88 0
 151 0000 0E94 0000 		call init_mcp23018
 152               	.LVL4:
 153 0004 8093 0000 		sts mcp23018_status,r24
  91:matrix.c      ****     unselect_rows();
 154               		.loc 1 91 0
 155 0008 0E94 0000 		call unselect_rows
 156               	.LVL5:
 157               	.LBB27:
 158               	.LBB28:
 227:matrix.c      ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 159               		.loc 1 227 0
 160 000c 80B3      		in r24,0x10
 161 000e 8C70      		andi r24,lo8(12)
 162 0010 80BB      		out 0x10,r24
 228:matrix.c      ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 163               		.loc 1 228 0
 164 0012 81B3      		in r24,0x11
 165 0014 836F      		ori r24,lo8(-13)
 166 0016 81BB      		out 0x11,r24
 167               	.LVL6:
 168 0018 E0E0      		ldi r30,lo8(matrix)
 169 001a F0E0      		ldi r31,hi8(matrix)
 170 001c A0E0      		ldi r26,lo8(matrix_debouncing)
 171 001e B0E0      		ldi r27,hi8(matrix_debouncing)
 172               	.LVL7:
 173               	.L13:
 174               	.LBE28:
 175               	.LBE27:
 176               	.LBB29:
  96:matrix.c      ****         matrix[i] = 0;
 177               		.loc 1 96 0 discriminator 2
 178 0020 1192      		st Z+,__zero_reg__
 179               	.LVL8:
  97:matrix.c      ****         matrix_debouncing[i] = 0;
 180               		.loc 1 97 0 discriminator 2
 181 0022 1D92      		st X+,__zero_reg__
 182               	.LVL9:
  95:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 183               		.loc 1 95 0 discriminator 2
 184 0024 80E0      		ldi r24,hi8(matrix+14)
 185 0026 E030      		cpi r30,lo8(matrix+14)
 186 0028 F807      		cpc r31,r24
 187 002a 01F4      		brne .L13
 188               	.LBE29:
 105:matrix.c      ****     if (matrix_init_kb) {
 189               		.loc 1 105 0
 190 002c 80E0      		ldi r24,lo8(gs(matrix_init_kb))
 191 002e 90E0      		ldi r25,hi8(gs(matrix_init_kb))
 192 0030 892B      		or r24,r25
 193 0032 01F0      		breq .L11
 106:matrix.c      ****         (*matrix_init_kb)();
 194               		.loc 1 106 0
 195 0034 0C94 0000 		jmp matrix_init_kb
 196               	.LVL10:
 197               	.L11:
 198 0038 0895      		ret
 199               		.cfi_endproc
 200               	.LFE124:
 202               		.section	.text.matrix_scan,"ax",@progbits
 203               	.global	matrix_scan
 205               	matrix_scan:
 206               	.LFB125:
 112:matrix.c      **** {
 207               		.loc 1 112 0
 208               		.cfi_startproc
 209 0000 9F92      		push r9
 210               	.LCFI0:
 211               		.cfi_def_cfa_offset 3
 212               		.cfi_offset 9, -2
 213 0002 AF92      		push r10
 214               	.LCFI1:
 215               		.cfi_def_cfa_offset 4
 216               		.cfi_offset 10, -3
 217 0004 BF92      		push r11
 218               	.LCFI2:
 219               		.cfi_def_cfa_offset 5
 220               		.cfi_offset 11, -4
 221 0006 CF92      		push r12
 222               	.LCFI3:
 223               		.cfi_def_cfa_offset 6
 224               		.cfi_offset 12, -5
 225 0008 DF92      		push r13
 226               	.LCFI4:
 227               		.cfi_def_cfa_offset 7
 228               		.cfi_offset 13, -6
 229 000a EF92      		push r14
 230               	.LCFI5:
 231               		.cfi_def_cfa_offset 8
 232               		.cfi_offset 14, -7
 233 000c FF92      		push r15
 234               	.LCFI6:
 235               		.cfi_def_cfa_offset 9
 236               		.cfi_offset 15, -8
 237 000e 0F93      		push r16
 238               	.LCFI7:
 239               		.cfi_def_cfa_offset 10
 240               		.cfi_offset 16, -9
 241 0010 1F93      		push r17
 242               	.LCFI8:
 243               		.cfi_def_cfa_offset 11
 244               		.cfi_offset 17, -10
 245 0012 CF93      		push r28
 246               	.LCFI9:
 247               		.cfi_def_cfa_offset 12
 248               		.cfi_offset 28, -11
 249 0014 DF93      		push r29
 250               	.LCFI10:
 251               		.cfi_def_cfa_offset 13
 252               		.cfi_offset 29, -12
 253               	/* prologue: function */
 254               	/* frame size = 0 */
 255               	/* stack size = 11 */
 256               	.L__stack_usage = 11
 113:matrix.c      ****     if (mcp23018_status) { // if there was an error
 257               		.loc 1 113 0
 258 0016 8091 0000 		lds r24,mcp23018_status
 259 001a 8823      		tst r24
 260 001c 01F0      		breq .L17
 114:matrix.c      ****         if (++mcp23018_reset_loop == 0) {
 261               		.loc 1 114 0
 262 001e 8091 0000 		lds r24,mcp23018_reset_loop
 263 0022 8F5F      		subi r24,lo8(-(1))
 264 0024 8093 0000 		sts mcp23018_reset_loop,r24
 265 0028 8111      		cpse r24,__zero_reg__
 266 002a 00C0      		rjmp .L17
 117:matrix.c      ****             print("trying to reset mcp23018\n");
 267               		.loc 1 117 0
 268 002c 80E0      		ldi r24,lo8(__c.4784)
 269 002e 90E0      		ldi r25,hi8(__c.4784)
 270 0030 0E94 0000 		call xputs
 271               	.LVL11:
 118:matrix.c      ****             mcp23018_status = init_mcp23018();
 272               		.loc 1 118 0
 273 0034 0E94 0000 		call init_mcp23018
 274               	.LVL12:
 275 0038 8093 0000 		sts mcp23018_status,r24
 119:matrix.c      ****             if (mcp23018_status) {
 276               		.loc 1 119 0
 277 003c 8823      		tst r24
 278 003e 01F0      		breq .L19
 120:matrix.c      ****                 print("left side not responding\n");
 279               		.loc 1 120 0
 280 0040 80E0      		ldi r24,lo8(__c.4786)
 281 0042 90E0      		ldi r25,hi8(__c.4786)
 282 0044 0E94 0000 		call xputs
 283               	.LVL13:
 284 0048 00C0      		rjmp .L17
 285               	.L19:
 122:matrix.c      ****                 print("left side attached\n");
 286               		.loc 1 122 0
 287 004a 80E0      		ldi r24,lo8(__c.4788)
 288 004c 90E0      		ldi r25,hi8(__c.4788)
 289 004e 0E94 0000 		call xputs
 290               	.LVL14:
 123:matrix.c      ****                 ergodox_blink_all_leds();
 291               		.loc 1 123 0
 292 0052 0E94 0000 		call ergodox_blink_all_leds
 293               	.LVL15:
 294               	.L17:
 112:matrix.c      **** {
 295               		.loc 1 112 0 discriminator 1
 296 0056 00E0      		ldi r16,lo8(matrix_debouncing)
 297 0058 10E0      		ldi r17,hi8(matrix_debouncing)
 298 005a C0E0      		ldi r28,0
 299 005c D0E0      		ldi r29,0
 300 005e BB24      		clr r11
 301 0060 B394      		inc r11
 302               	.LBB48:
 303               	.LBB49:
 304               	.LBB50:
 305               	.LBB51:
 250:matrix.c      ****         return
 306               		.loc 1 250 0 discriminator 1
 307 0062 82E0      		ldi r24,lo8(2)
 308 0064 A82E      		mov r10,r24
 309               	.LBE51:
 310               	.LBE50:
 311               	.LBB58:
 312               	.LBB59:
 294:matrix.c      **** }
 295:matrix.c      **** 
 296:matrix.c      **** static void select_row(uint8_t row)
 297:matrix.c      **** {
 298:matrix.c      ****     if (row < 7) {
 299:matrix.c      ****         // select on mcp23018
 300:matrix.c      ****         if (mcp23018_status) { // if there was an error
 301:matrix.c      ****             // do nothing
 302:matrix.c      ****         } else {
 303:matrix.c      ****             // set active row low  : 0
 304:matrix.c      ****             // set other rows hi-Z : 1
 305:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 306:matrix.c      ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 307:matrix.c      ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row)
 313               		.loc 1 307 0 discriminator 1
 314 0066 CC24      		clr r12
 315 0068 C394      		inc r12
 316 006a D12C      		mov r13,__zero_reg__
 317               	.LBE59:
 318               	.LBE58:
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 319               		.loc 1 148 0 discriminator 1
 320 006c 20E0      		ldi r18,lo8(__c.4794)
 321 006e E22E      		mov r14,r18
 322 0070 20E0      		ldi r18,hi8(__c.4794)
 323 0072 F22E      		mov r15,r18
 324               	.LVL16:
 325               	.L49:
 326               	.LBB61:
 327               	.LBB60:
 298:matrix.c      ****     if (row < 7) {
 328               		.loc 1 298 0
 329 0074 C730      		cpi r28,lo8(7)
 330 0076 00F4      		brsh .L20
 300:matrix.c      ****         if (mcp23018_status) { // if there was an error
 331               		.loc 1 300 0
 332 0078 8091 0000 		lds r24,mcp23018_status
 333 007c 8111      		cpse r24,__zero_reg__
 334 007e 00C0      		rjmp .L21
 305:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 335               		.loc 1 305 0
 336 0080 80E4      		ldi r24,lo8(64)
 337 0082 0E94 0000 		call i2c_start
 338               	.LVL17:
 339 0086 8093 0000 		sts mcp23018_status,r24
 340 008a 8111      		cpse r24,__zero_reg__
 341 008c 00C0      		rjmp .L23
 306:matrix.c      ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 342               		.loc 1 306 0
 343 008e 82E1      		ldi r24,lo8(18)
 344 0090 0E94 0000 		call i2c_write
 345               	.LVL18:
 346 0094 8093 0000 		sts mcp23018_status,r24
 347 0098 8111      		cpse r24,__zero_reg__
 348 009a 00C0      		rjmp .L23
 349               		.loc 1 307 0
 350 009c C601      		movw r24,r12
 351 009e 0C2E      		mov r0,r28
 352 00a0 00C0      		rjmp 2f
 353               		1:
 354 00a2 880F      		lsl r24
 355               		2:
 356 00a4 0A94      		dec r0
 357 00a6 02F4      		brpl 1b
 358 00a8 8095      		com r24
 359 00aa 0E94 0000 		call i2c_write
 360               	.LVL19:
 361 00ae 8093 0000 		sts mcp23018_status,r24
 362               	.L23:
 308:matrix.c      ****                                   & ~(0<<7)
 309:matrix.c      ****                               );                                if (mcp23018_status) goto out;
 310:matrix.c      ****         out:
 311:matrix.c      ****             i2c_stop();
 363               		.loc 1 311 0
 364 00b2 0E94 0000 		call i2c_stop
 365               	.LVL20:
 366 00b6 00C0      		rjmp .L21
 367               	.L20:
 312:matrix.c      ****         }
 313:matrix.c      ****     } else {
 314:matrix.c      ****         // select on teensy
 315:matrix.c      ****         // Output low(DDR:1, PORT:0) to select
 316:matrix.c      ****         switch (row) {
 368               		.loc 1 316 0
 369 00b8 CA30      		cpi r28,lo8(10)
 370 00ba 01F0      		breq .L26
 371 00bc 00F4      		brsh .L27
 372 00be C830      		cpi r28,lo8(8)
 373 00c0 01F0      		breq .L28
 374 00c2 C930      		cpi r28,lo8(9)
 375 00c4 01F0      		breq .L29
 376 00c6 00C0      		rjmp .L25
 377               	.L27:
 378 00c8 CC30      		cpi r28,lo8(12)
 379 00ca 01F0      		breq .L30
 380 00cc 00F0      		brlo .L31
 381 00ce CD30      		cpi r28,lo8(13)
 382 00d0 01F0      		breq .L32
 383               	.L25:
 317:matrix.c      ****             case 7:
 318:matrix.c      ****                 DDRB  |= (1<<0);
 384               		.loc 1 318 0
 385 00d2 209A      		sbi 0x4,0
 319:matrix.c      ****                 PORTB &= ~(1<<0);
 386               		.loc 1 319 0
 387 00d4 2898      		cbi 0x5,0
 388 00d6 00C0      		rjmp .L33
 389               	.L28:
 320:matrix.c      ****                 break;
 321:matrix.c      ****             case 8:
 322:matrix.c      ****                 DDRB  |= (1<<1);
 390               		.loc 1 322 0
 391 00d8 219A      		sbi 0x4,1
 323:matrix.c      ****                 PORTB &= ~(1<<1);
 392               		.loc 1 323 0
 393 00da 2998      		cbi 0x5,1
 394 00dc 00C0      		rjmp .L33
 395               	.L29:
 324:matrix.c      ****                 break;
 325:matrix.c      ****             case 9:
 326:matrix.c      ****                 DDRB  |= (1<<2);
 396               		.loc 1 326 0
 397 00de 229A      		sbi 0x4,2
 327:matrix.c      ****                 PORTB &= ~(1<<2);
 398               		.loc 1 327 0
 399 00e0 2A98      		cbi 0x5,2
 400 00e2 00C0      		rjmp .L33
 401               	.L26:
 328:matrix.c      ****                 break;
 329:matrix.c      ****             case 10:
 330:matrix.c      ****                 DDRB  |= (1<<3);
 402               		.loc 1 330 0
 403 00e4 239A      		sbi 0x4,3
 331:matrix.c      ****                 PORTB &= ~(1<<3);
 404               		.loc 1 331 0
 405 00e6 2B98      		cbi 0x5,3
 406 00e8 00C0      		rjmp .L33
 407               	.L31:
 332:matrix.c      ****                 break;
 333:matrix.c      ****             case 11:
 334:matrix.c      ****                 DDRD  |= (1<<2);
 408               		.loc 1 334 0
 409 00ea 529A      		sbi 0xa,2
 410 00ec 00C0      		rjmp .L80
 411               	.L30:
 335:matrix.c      ****                 PORTD &= ~(1<<3);
 336:matrix.c      ****                 break;
 337:matrix.c      ****             case 12:
 338:matrix.c      ****                 DDRD  |= (1<<3);
 412               		.loc 1 338 0
 413 00ee 539A      		sbi 0xa,3
 414               	.L80:
 339:matrix.c      ****                 PORTD &= ~(1<<3);
 415               		.loc 1 339 0
 416 00f0 5B98      		cbi 0xb,3
 417 00f2 00C0      		rjmp .L33
 418               	.L32:
 340:matrix.c      ****                 break;
 341:matrix.c      ****             case 13:
 342:matrix.c      ****                 DDRC  |= (1<<6);
 419               		.loc 1 342 0
 420 00f4 3E9A      		sbi 0x7,6
 343:matrix.c      ****                 PORTC &= ~(1<<6);
 421               		.loc 1 343 0
 422 00f6 4698      		cbi 0x8,6
 423               	.L33:
 424               	.LVL21:
 425               	.LBE60:
 426               	.LBE61:
 427               	.LBB62:
 428               	.LBB56:
 429               	.LBB52:
 430               	.LBB53:
 431               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 432               		.loc 2 245 0
 433 00f8 E0EA      		ldi r30,lo8(-96)
 434 00fa EA95      		1: dec r30
 435 00fc 01F4      		brne 1b
 436               	.LBE53:
 437               	.LBE52:
 251:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 438               		.loc 1 251 0
 439 00fe 8FB1      		in r24,0xf
 250:matrix.c      ****         return
 440               		.loc 1 250 0
 441 0100 7999      		sbic 0xf,1
 442 0102 00C0      		rjmp .L81
 443 0104 92E0      		ldi r25,lo8(2)
 444               	.L56:
 251:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 445               		.loc 1 251 0
 446 0106 8170      		andi r24,lo8(1)
 447 0108 8B25      		eor r24,r11
 250:matrix.c      ****         return
 448               		.loc 1 250 0
 449 010a 892B      		or r24,r25
 450 010c 7C9B      		sbis 0xf,4
 451 010e 00C0      		rjmp .L58
 452 0110 90E0      		ldi r25,0
 453 0112 00C0      		rjmp .L38
 454               	.L58:
 455 0114 94E0      		ldi r25,lo8(4)
 456               	.L38:
 457 0116 892B      		or r24,r25
 458 0118 7D9B      		sbis 0xf,5
 459 011a 00C0      		rjmp .L59
 460 011c 90E0      		ldi r25,0
 461 011e 00C0      		rjmp .L39
 462               	.L59:
 463 0120 98E0      		ldi r25,lo8(8)
 464               	.L39:
 465 0122 892B      		or r24,r25
 466 0124 7E9B      		sbis 0xf,6
 467 0126 00C0      		rjmp .L60
 468 0128 90E0      		ldi r25,0
 469 012a 00C0      		rjmp .L40
 470               	.L60:
 471 012c 90E1      		ldi r25,lo8(16)
 472               	.L40:
 473 012e 892B      		or r24,r25
 256:matrix.c      ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 474               		.loc 1 256 0
 475 0130 9FB1      		in r25,0xf
 250:matrix.c      ****         return
 476               		.loc 1 250 0
 477 0132 9095      		com r25
 478 0134 991F      		rol r25
 479 0136 9927      		clr r25
 480 0138 991F      		rol r25
 481 013a 9295      		swap r25
 482 013c 990F      		lsl r25
 483 013e 907E      		andi r25,lo8(-32)
 484 0140 892B      		or r24,r25
 485 0142 00C0      		rjmp .L37
 486               	.LVL22:
 487               	.L21:
 234:matrix.c      ****         if (mcp23018_status) { // if there was an error
 488               		.loc 1 234 0
 489 0144 8091 0000 		lds r24,mcp23018_status
 490 0148 8111      		cpse r24,__zero_reg__
 491 014a 00C0      		rjmp .L63
 492               	.LVL23:
 493               	.LBB54:
 238:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 494               		.loc 1 238 0
 495 014c 80E4      		ldi r24,lo8(64)
 496 014e 0E94 0000 		call i2c_start
 497               	.LVL24:
 498 0152 8093 0000 		sts mcp23018_status,r24
 499 0156 8823      		tst r24
 500 0158 01F4      		brne .+2
 501 015a 00C0      		rjmp .L34
 502               	.L36:
 237:matrix.c      ****             uint8_t data = 0;
 503               		.loc 1 237 0
 504 015c 912C      		mov r9,__zero_reg__
 505               	.LVL25:
 506               	.L35:
 244:matrix.c      ****             i2c_stop();
 507               		.loc 1 244 0
 508 015e 0E94 0000 		call i2c_stop
 509               	.LVL26:
 245:matrix.c      ****             return data;
 510               		.loc 1 245 0
 511 0162 892D      		mov r24,r9
 512               	.LVL27:
 513               	.L37:
 514               	.LBE54:
 515               	.LBE56:
 516               	.LBE62:
 145:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 517               		.loc 1 145 0
 518 0164 F801      		movw r30,r16
 519 0166 9081      		ld r25,Z
 520 0168 9817      		cp r25,r24
 521 016a 01F0      		breq .L42
 146:matrix.c      ****             matrix_debouncing[i] = cols;
 522               		.loc 1 146 0
 523 016c 8083      		st Z,r24
 147:matrix.c      ****             if (debouncing) {
 524               		.loc 1 147 0
 525 016e 8091 0000 		lds r24,debouncing
 526 0172 8823      		tst r24
 527 0174 01F0      		breq .L44
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 528               		.loc 1 148 0
 529 0176 8091 0000 		lds r24,debug_config
 530 017a 80FF      		sbrs r24,0
 531 017c 00C0      		rjmp .L45
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 532               		.loc 1 148 0 is_stmt 0 discriminator 1
 533 017e 80E0      		ldi r24,lo8(__c.4792)
 534 0180 90E0      		ldi r25,hi8(__c.4792)
 535 0182 0E94 0000 		call xputs
 536               	.LVL28:
 537               	.L45:
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 538               		.loc 1 148 0 discriminator 2
 539 0186 8091 0000 		lds r24,debug_config
 540 018a 80FF      		sbrs r24,0
 541 018c 00C0      		rjmp .L46
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 542               		.loc 1 148 0 discriminator 1
 543 018e 8091 0000 		lds r24,debouncing
 544 0192 1F92      		push __zero_reg__
 545               	.LCFI11:
 546               		.cfi_def_cfa_offset 14
 547 0194 8F93      		push r24
 548               	.LCFI12:
 549               		.cfi_def_cfa_offset 15
 550 0196 FF92      		push r15
 551               	.LCFI13:
 552               		.cfi_def_cfa_offset 16
 553 0198 EF92      		push r14
 554               	.LCFI14:
 555               		.cfi_def_cfa_offset 17
 556 019a 0E94 0000 		call __xprintf
 557               	.LVL29:
 558 019e 0F90      		pop __tmp_reg__
 559 01a0 0F90      		pop __tmp_reg__
 560 01a2 0F90      		pop __tmp_reg__
 561 01a4 0F90      		pop __tmp_reg__
 562               	.LCFI15:
 563               		.cfi_def_cfa_offset 13
 564               	.L46:
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 565               		.loc 1 148 0 discriminator 2
 566 01a6 8091 0000 		lds r24,debug_config
 567 01aa 80FF      		sbrs r24,0
 568 01ac 00C0      		rjmp .L44
 148:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 569               		.loc 1 148 0 discriminator 1
 570 01ae 80E0      		ldi r24,lo8(__c.4796)
 571 01b0 90E0      		ldi r25,hi8(__c.4796)
 572 01b2 0E94 0000 		call xputs
 573               	.LVL30:
 574               	.L44:
 150:matrix.c      ****             debouncing = DEBOUNCE;
 575               		.loc 1 150 0 is_stmt 1
 576 01b6 A092 0000 		sts debouncing,r10
 577               	.L42:
 152:matrix.c      ****         unselect_rows();
 578               		.loc 1 152 0
 579 01ba 0E94 0000 		call unselect_rows
 580               	.LVL31:
 581 01be 2196      		adiw r28,1
 582               	.LVL32:
 583 01c0 0F5F      		subi r16,-1
 584 01c2 1F4F      		sbci r17,-1
 585               	.LBE49:
 142:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 586               		.loc 1 142 0
 587 01c4 CE30      		cpi r28,14
 588 01c6 D105      		cpc r29,__zero_reg__
 589 01c8 01F0      		breq .+2
 590 01ca 00C0      		rjmp .L49
 591               	.LBE48:
 155:matrix.c      ****     if (debouncing) {
 592               		.loc 1 155 0
 593 01cc 8091 0000 		lds r24,debouncing
 594 01d0 8823      		tst r24
 595 01d2 01F0      		breq .L51
 156:matrix.c      ****         if (--debouncing) {
 596               		.loc 1 156 0
 597 01d4 8150      		subi r24,lo8(-(-1))
 598 01d6 8093 0000 		sts debouncing,r24
 599 01da 8823      		tst r24
 600 01dc 01F0      		breq .L52
 601               	.LVL33:
 602               	.LBB65:
 603               	.LBB66:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 604               		.loc 2 163 0
 605 01de 8FE9      		ldi r24,lo8(3999)
 606 01e0 9FE0      		ldi r25,hi8(3999)
 607 01e2 0197      		1: sbiw r24,1
 608 01e4 01F4      		brne 1b
 609 01e6 00C0      		rjmp .
 610 01e8 0000      		nop
 611 01ea 00C0      		rjmp .L51
 612               	.LVL34:
 613               	.L52:
 614 01ec A0E0      		ldi r26,lo8(matrix)
 615 01ee B0E0      		ldi r27,hi8(matrix)
 616               	.LBE66:
 617               	.LBE65:
 156:matrix.c      ****         if (--debouncing) {
 618               		.loc 1 156 0
 619 01f0 E0E0      		ldi r30,lo8(matrix_debouncing)
 620 01f2 F0E0      		ldi r31,hi8(matrix_debouncing)
 621               	.L54:
 622               	.LVL35:
 623               	.LBB67:
 160:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 624               		.loc 1 160 0 discriminator 2
 625 01f4 8191      		ld r24,Z+
 626               	.LVL36:
 627 01f6 8D93      		st X+,r24
 628               	.LVL37:
 159:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 629               		.loc 1 159 0 discriminator 2
 630 01f8 90E0      		ldi r25,hi8(matrix_debouncing+14)
 631 01fa E030      		cpi r30,lo8(matrix_debouncing+14)
 632 01fc F907      		cpc r31,r25
 633 01fe 01F4      		brne .L54
 634               	.LVL38:
 635               	.L51:
 636               	.LBE67:
 166:matrix.c      ****     if (matrix_scan_kb) {
 637               		.loc 1 166 0
 638 0200 80E0      		ldi r24,lo8(gs(matrix_scan_kb))
 639 0202 90E0      		ldi r25,hi8(gs(matrix_scan_kb))
 640 0204 892B      		or r24,r25
 641 0206 01F0      		breq .L68
 167:matrix.c      ****         (*matrix_scan_kb)();
 642               		.loc 1 167 0
 643 0208 0E94 0000 		call matrix_scan_kb
 644               	.LVL39:
 645 020c 00C0      		rjmp .L68
 646               	.LVL40:
 647               	.L81:
 648               	.LBB68:
 649               	.LBB64:
 650               	.LBB63:
 651               	.LBB57:
 250:matrix.c      ****         return
 652               		.loc 1 250 0
 653 020e 90E0      		ldi r25,0
 654 0210 00C0      		rjmp .L56
 655               	.LVL41:
 656               	.L34:
 657               	.LBB55:
 239:matrix.c      ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 658               		.loc 1 239 0
 659 0212 83E1      		ldi r24,lo8(19)
 660 0214 0E94 0000 		call i2c_write
 661               	.LVL42:
 662 0218 8093 0000 		sts mcp23018_status,r24
 663 021c 8111      		cpse r24,__zero_reg__
 664 021e 00C0      		rjmp .L36
 240:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 665               		.loc 1 240 0
 666 0220 81E4      		ldi r24,lo8(65)
 667 0222 0E94 0000 		call i2c_start
 668               	.LVL43:
 669 0226 8093 0000 		sts mcp23018_status,r24
 670 022a 8111      		cpse r24,__zero_reg__
 671 022c 00C0      		rjmp .L36
 241:matrix.c      ****             data = i2c_readNak();
 672               		.loc 1 241 0
 673 022e 0E94 0000 		call i2c_readNak
 674               	.LVL44:
 242:matrix.c      ****             data = ~data;
 675               		.loc 1 242 0
 676 0232 982E      		mov r9,r24
 677 0234 9094      		com r9
 678               	.LVL45:
 679 0236 00C0      		rjmp .L35
 680               	.LVL46:
 681               	.L63:
 682               	.LBE55:
 235:matrix.c      ****             return 0;
 683               		.loc 1 235 0
 684 0238 80E0      		ldi r24,0
 685 023a 00C0      		rjmp .L37
 686               	.LVL47:
 687               	.L68:
 688               	.LBE57:
 689               	.LBE63:
 690               	.LBE64:
 691               	.LBE68:
 171:matrix.c      **** }
 692               		.loc 1 171 0
 693 023c 81E0      		ldi r24,lo8(1)
 694               	/* epilogue start */
 695 023e DF91      		pop r29
 696 0240 CF91      		pop r28
 697               	.LVL48:
 698 0242 1F91      		pop r17
 699 0244 0F91      		pop r16
 700 0246 FF90      		pop r15
 701 0248 EF90      		pop r14
 702 024a DF90      		pop r13
 703 024c CF90      		pop r12
 704 024e BF90      		pop r11
 705 0250 AF90      		pop r10
 706 0252 9F90      		pop r9
 707 0254 0895      		ret
 708               		.cfi_endproc
 709               	.LFE125:
 711               		.section	.text.matrix_is_modified,"ax",@progbits
 712               	.global	matrix_is_modified
 714               	matrix_is_modified:
 715               	.LFB126:
 174:matrix.c      **** {
 716               		.loc 1 174 0
 717               		.cfi_startproc
 718               	/* prologue: function */
 719               	/* frame size = 0 */
 720               	/* stack size = 0 */
 721               	.L__stack_usage = 0
 175:matrix.c      ****     if (debouncing) return false;
 722               		.loc 1 175 0
 723 0000 81E0      		ldi r24,lo8(1)
 724 0002 9091 0000 		lds r25,debouncing
 725 0006 9111      		cpse r25,__zero_reg__
 726 0008 80E0      		ldi r24,0
 727               	.L83:
 177:matrix.c      **** }
 728               		.loc 1 177 0
 729 000a 0895      		ret
 730               		.cfi_endproc
 731               	.LFE126:
 733               		.section	.text.matrix_is_on,"ax",@progbits
 734               	.global	matrix_is_on
 736               	matrix_is_on:
 737               	.LFB127:
 181:matrix.c      **** {
 738               		.loc 1 181 0
 739               		.cfi_startproc
 740               	.LVL49:
 741               	/* prologue: function */
 742               	/* frame size = 0 */
 743               	/* stack size = 0 */
 744               	.L__stack_usage = 0
 182:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 745               		.loc 1 182 0
 746 0000 E82F      		mov r30,r24
 747 0002 F0E0      		ldi r31,0
 748 0004 E050      		subi r30,lo8(-(matrix))
 749 0006 F040      		sbci r31,hi8(-(matrix))
 750 0008 2081      		ld r18,Z
 751 000a 30E0      		ldi r19,0
 752 000c 81E0      		ldi r24,lo8(1)
 753 000e 90E0      		ldi r25,0
 754               	.LVL50:
 755 0010 00C0      		rjmp 2f
 756               		1:
 757 0012 880F      		lsl r24
 758 0014 991F      		rol r25
 759               		2:
 760 0016 6A95      		dec r22
 761 0018 02F4      		brpl 1b
 762 001a 2823      		and r18,r24
 763 001c 3923      		and r19,r25
 764 001e 81E0      		ldi r24,lo8(1)
 765 0020 232B      		or r18,r19
 766 0022 01F4      		brne .L88
 767 0024 80E0      		ldi r24,0
 768               	.L88:
 183:matrix.c      **** }
 769               		.loc 1 183 0
 770 0026 0895      		ret
 771               		.cfi_endproc
 772               	.LFE127:
 774               		.section	.text.matrix_get_row,"ax",@progbits
 775               	.global	matrix_get_row
 777               	matrix_get_row:
 778               	.LFB128:
 187:matrix.c      **** {
 779               		.loc 1 187 0
 780               		.cfi_startproc
 781               	.LVL51:
 782               	/* prologue: function */
 783               	/* frame size = 0 */
 784               	/* stack size = 0 */
 785               	.L__stack_usage = 0
 188:matrix.c      ****     return matrix[row];
 786               		.loc 1 188 0
 787 0000 E82F      		mov r30,r24
 788 0002 F0E0      		ldi r31,0
 789 0004 E050      		subi r30,lo8(-(matrix))
 790 0006 F040      		sbci r31,hi8(-(matrix))
 189:matrix.c      **** }
 791               		.loc 1 189 0
 792 0008 8081      		ld r24,Z
 793               	.LVL52:
 794 000a 0895      		ret
 795               		.cfi_endproc
 796               	.LFE128:
 798               		.section	.text.matrix_print,"ax",@progbits
 799               	.global	matrix_print
 801               	matrix_print:
 802               	.LFB129:
 192:matrix.c      **** {
 803               		.loc 1 192 0
 804               		.cfi_startproc
 805 0000 CF92      		push r12
 806               	.LCFI16:
 807               		.cfi_def_cfa_offset 3
 808               		.cfi_offset 12, -2
 809 0002 DF92      		push r13
 810               	.LCFI17:
 811               		.cfi_def_cfa_offset 4
 812               		.cfi_offset 13, -3
 813 0004 EF92      		push r14
 814               	.LCFI18:
 815               		.cfi_def_cfa_offset 5
 816               		.cfi_offset 14, -4
 817 0006 FF92      		push r15
 818               	.LCFI19:
 819               		.cfi_def_cfa_offset 6
 820               		.cfi_offset 15, -5
 821 0008 0F93      		push r16
 822               	.LCFI20:
 823               		.cfi_def_cfa_offset 7
 824               		.cfi_offset 16, -6
 825 000a 1F93      		push r17
 826               	.LCFI21:
 827               		.cfi_def_cfa_offset 8
 828               		.cfi_offset 17, -7
 829 000c CF93      		push r28
 830               	.LCFI22:
 831               		.cfi_def_cfa_offset 9
 832               		.cfi_offset 28, -8
 833 000e DF93      		push r29
 834               	.LCFI23:
 835               		.cfi_def_cfa_offset 10
 836               		.cfi_offset 29, -9
 837               	/* prologue: function */
 838               	/* frame size = 0 */
 839               	/* stack size = 8 */
 840               	.L__stack_usage = 8
 193:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 841               		.loc 1 193 0
 842 0010 80E0      		ldi r24,lo8(__c.4818)
 843 0012 90E0      		ldi r25,hi8(__c.4818)
 844 0014 0E94 0000 		call xputs
 845 0018 30E0      		ldi r19,lo8(matrix)
 846 001a E32E      		mov r14,r19
 847 001c 30E0      		ldi r19,hi8(matrix)
 848 001e F32E      		mov r15,r19
 849 0020 C0E0      		ldi r28,0
 850 0022 D0E0      		ldi r29,0
 851               	.LBB69:
 195:matrix.c      ****         phex(row); print(": ");
 852               		.loc 1 195 0
 853 0024 40E0      		ldi r20,lo8(__c.4821)
 854 0026 C42E      		mov r12,r20
 855 0028 40E0      		ldi r20,hi8(__c.4821)
 856 002a D42E      		mov r13,r20
 196:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 857               		.loc 1 196 0
 858 002c 00E0      		ldi r16,lo8(__c.4825)
 859 002e 10E0      		ldi r17,hi8(__c.4825)
 860               	.L92:
 195:matrix.c      ****         phex(row); print(": ");
 861               		.loc 1 195 0 discriminator 2
 862 0030 DF93      		push r29
 863               	.LCFI24:
 864               		.cfi_def_cfa_offset 11
 865 0032 CF93      		push r28
 866               	.LCFI25:
 867               		.cfi_def_cfa_offset 12
 868 0034 DF92      		push r13
 869               	.LCFI26:
 870               		.cfi_def_cfa_offset 13
 871 0036 CF92      		push r12
 872               	.LCFI27:
 873               		.cfi_def_cfa_offset 14
 874 0038 0E94 0000 		call __xprintf
 875 003c 80E0      		ldi r24,lo8(__c.4823)
 876 003e 90E0      		ldi r25,hi8(__c.4823)
 877 0040 0E94 0000 		call xputs
 878               	.LBB70:
 879               	.LBB71:
 188:matrix.c      ****     return matrix[row];
 880               		.loc 1 188 0 discriminator 2
 881 0044 F701      		movw r30,r14
 882 0046 8191      		ld r24,Z+
 883 0048 7F01      		movw r14,r30
 884               	.LBE71:
 885               	.LBE70:
 196:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 886               		.loc 1 196 0 discriminator 2
 887 004a 90E0      		ldi r25,0
 888 004c 0E94 0000 		call bitrev16
 889 0050 9F93      		push r25
 890               	.LCFI28:
 891               		.cfi_def_cfa_offset 15
 892 0052 8F93      		push r24
 893               	.LCFI29:
 894               		.cfi_def_cfa_offset 16
 895 0054 1F93      		push r17
 896               	.LCFI30:
 897               		.cfi_def_cfa_offset 17
 898 0056 0F93      		push r16
 899               	.LCFI31:
 900               		.cfi_def_cfa_offset 18
 901 0058 0E94 0000 		call __xprintf
 197:matrix.c      ****         print("\n");
 902               		.loc 1 197 0 discriminator 2
 903 005c 80E0      		ldi r24,lo8(__c.4827)
 904 005e 90E0      		ldi r25,hi8(__c.4827)
 905 0060 0E94 0000 		call xputs
 906 0064 2196      		adiw r28,1
 194:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 907               		.loc 1 194 0 discriminator 2
 908 0066 8DB7      		in r24,__SP_L__
 909 0068 9EB7      		in r25,__SP_H__
 910 006a 0896      		adiw r24,8
 911 006c 0FB6      		in __tmp_reg__,__SREG__
 912 006e F894      		cli
 913 0070 9EBF      		out __SP_H__,r25
 914 0072 0FBE      		out __SREG__,__tmp_reg__
 915 0074 8DBF      		out __SP_L__,r24
 916               	.LCFI32:
 917               		.cfi_def_cfa_offset 10
 918 0076 CE30      		cpi r28,14
 919 0078 D105      		cpc r29,__zero_reg__
 920 007a 01F4      		brne .L92
 921               	/* epilogue start */
 922               	.LBE69:
 199:matrix.c      **** }
 923               		.loc 1 199 0
 924 007c DF91      		pop r29
 925 007e CF91      		pop r28
 926 0080 1F91      		pop r17
 927 0082 0F91      		pop r16
 928 0084 FF90      		pop r15
 929 0086 EF90      		pop r14
 930 0088 DF90      		pop r13
 931 008a CF90      		pop r12
 932 008c 0895      		ret
 933               		.cfi_endproc
 934               	.LFE129:
 936               		.section	.text.matrix_key_count,"ax",@progbits
 937               	.global	matrix_key_count
 939               	matrix_key_count:
 940               	.LFB130:
 202:matrix.c      **** {
 941               		.loc 1 202 0
 942               		.cfi_startproc
 943 0000 1F93      		push r17
 944               	.LCFI33:
 945               		.cfi_def_cfa_offset 3
 946               		.cfi_offset 17, -2
 947 0002 CF93      		push r28
 948               	.LCFI34:
 949               		.cfi_def_cfa_offset 4
 950               		.cfi_offset 28, -3
 951 0004 DF93      		push r29
 952               	.LCFI35:
 953               		.cfi_def_cfa_offset 5
 954               		.cfi_offset 29, -4
 955               	/* prologue: function */
 956               	/* frame size = 0 */
 957               	/* stack size = 3 */
 958               	.L__stack_usage = 3
 959               	.LVL53:
 960 0006 C0E0      		ldi r28,lo8(matrix)
 961 0008 D0E0      		ldi r29,hi8(matrix)
 203:matrix.c      ****     uint8_t count = 0;
 962               		.loc 1 203 0
 963 000a 10E0      		ldi r17,0
 964               	.LVL54:
 965               	.L95:
 966               	.LBB72:
 205:matrix.c      ****         count += bitpop16(matrix[i]);
 967               		.loc 1 205 0 discriminator 2
 968 000c 8991      		ld r24,Y+
 969               	.LVL55:
 970 000e 90E0      		ldi r25,0
 971 0010 0E94 0000 		call bitpop16
 972               	.LVL56:
 973 0014 180F      		add r17,r24
 974               	.LVL57:
 204:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 975               		.loc 1 204 0 discriminator 2
 976 0016 80E0      		ldi r24,hi8(matrix+14)
 977 0018 C030      		cpi r28,lo8(matrix+14)
 978 001a D807      		cpc r29,r24
 979 001c 01F4      		brne .L95
 980               	.LBE72:
 208:matrix.c      **** }
 981               		.loc 1 208 0
 982 001e 812F      		mov r24,r17
 983               	/* epilogue start */
 984 0020 DF91      		pop r29
 985 0022 CF91      		pop r28
 986               	.LVL58:
 987 0024 1F91      		pop r17
 988               	.LVL59:
 989 0026 0895      		ret
 990               		.cfi_endproc
 991               	.LFE130:
 993               		.section	.progmem.data.__c.4827,"a",@progbits
 996               	__c.4827:
 997 0000 0A00      		.string	"\n"
 998               		.section	.progmem.data.__c.4825,"a",@progbits
 1001               	__c.4825:
 1002 0000 2530 3136 		.string	"%016b"
 1002      6200 
 1003               		.section	.progmem.data.__c.4823,"a",@progbits
 1006               	__c.4823:
 1007 0000 3A20 00   		.string	": "
 1008               		.section	.progmem.data.__c.4821,"a",@progbits
 1011               	__c.4821:
 1012 0000 2530 3258 		.string	"%02X"
 1012      00
 1013               		.section	.progmem.data.__c.4818,"a",@progbits
 1016               	__c.4818:
 1017 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 1017      2030 3132 
 1017      3334 3536 
 1017      3738 3941 
 1017      4243 4445 
 1018               		.section	.progmem.data.__c.4796,"a",@progbits
 1021               	__c.4796:
 1022 0000 0A00      		.string	"\n"
 1023               		.section	.progmem.data.__c.4794,"a",@progbits
 1026               	__c.4794:
 1027 0000 2530 3258 		.string	"%02X"
 1027      00
 1028               		.section	.progmem.data.__c.4792,"a",@progbits
 1031               	__c.4792:
 1032 0000 626F 756E 		.string	"bounce!: "
 1032      6365 213A 
 1032      2000 
 1033               		.section	.progmem.data.__c.4788,"a",@progbits
 1036               	__c.4788:
 1037 0000 6C65 6674 		.string	"left side attached\n"
 1037      2073 6964 
 1037      6520 6174 
 1037      7461 6368 
 1037      6564 0A00 
 1038               		.section	.progmem.data.__c.4786,"a",@progbits
 1041               	__c.4786:
 1042 0000 6C65 6674 		.string	"left side not responding\n"
 1042      2073 6964 
 1042      6520 6E6F 
 1042      7420 7265 
 1042      7370 6F6E 
 1043               		.section	.progmem.data.__c.4784,"a",@progbits
 1046               	__c.4784:
 1047 0000 7472 7969 		.string	"trying to reset mcp23018\n"
 1047      6E67 2074 
 1047      6F20 7265 
 1047      7365 7420 
 1047      6D63 7032 
 1048               		.section	.bss.mcp23018_reset_loop,"aw",@nobits
 1051               	mcp23018_reset_loop:
 1052 0000 00        		.zero	1
 1053               		.section	.bss.matrix_debouncing,"aw",@nobits
 1056               	matrix_debouncing:
 1057 0000 0000 0000 		.zero	14
 1057      0000 0000 
 1057      0000 0000 
 1057      0000 
 1058               		.section	.bss.matrix,"aw",@nobits
 1061               	matrix:
 1062 0000 0000 0000 		.zero	14
 1062      0000 0000 
 1062      0000 0000 
 1062      0000 
 1063               		.section	.data.debouncing,"aw",@progbits
 1066               	debouncing:
 1067 0000 02        		.byte	2
 1068               		.comm	keymap_config,2,1
 1069               		.text
 1070               	.Letext0:
 1071               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 1072               		.file 4 "../../tmk_core/common/debug.h"
 1073               		.file 5 "../../tmk_core/common/matrix.h"
 1074               		.file 6 "../../quantum/keymap_common.h"
 1075               		.file 7 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 1076               		.file 8 "ergodox_ez.h"
 1077               		.file 9 "i2cmaster.h"
 1078               		.file 10 "../../tmk_core/common/avr/xprintf.h"
 1079               		.file 11 "../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:2      *ABS*:0000003e __SP_H__
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:3      *ABS*:0000003d __SP_L__
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:4      *ABS*:0000003f __SREG__
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:6      *ABS*:00000001 __zero_reg__
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:13     .text.matrix_init_kb:00000000 matrix_init_kb
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:30     .text.matrix_scan_kb:00000000 matrix_scan_kb
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:45     .text.unselect_rows:00000000 unselect_rows
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:108    .text.matrix_rows:00000000 matrix_rows
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:125    .text.matrix_cols:00000000 matrix_cols
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:142    .text.matrix_init:00000000 matrix_init
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1061   .bss.matrix:00000000 matrix
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1056   .bss.matrix_debouncing:00000000 matrix_debouncing
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:205    .text.matrix_scan:00000000 matrix_scan
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1051   .bss.mcp23018_reset_loop:00000000 mcp23018_reset_loop
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1046   .progmem.data.__c.4784:00000000 __c.4784
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1041   .progmem.data.__c.4786:00000000 __c.4786
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1036   .progmem.data.__c.4788:00000000 __c.4788
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1026   .progmem.data.__c.4794:00000000 __c.4794
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1066   .data.debouncing:00000000 debouncing
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1031   .progmem.data.__c.4792:00000000 __c.4792
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1021   .progmem.data.__c.4796:00000000 __c.4796
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:714    .text.matrix_is_modified:00000000 matrix_is_modified
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:736    .text.matrix_is_on:00000000 matrix_is_on
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:777    .text.matrix_get_row:00000000 matrix_get_row
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:801    .text.matrix_print:00000000 matrix_print
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1016   .progmem.data.__c.4818:00000000 __c.4818
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1011   .progmem.data.__c.4821:00000000 __c.4821
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1001   .progmem.data.__c.4825:00000000 __c.4825
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:1006   .progmem.data.__c.4823:00000000 __c.4823
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:996    .progmem.data.__c.4827:00000000 __c.4827
/var/folders/1b/xfvjmdyj6l31z1llzpnz5cwr0000gn/T//ccztKXIa.s:939    .text.matrix_key_count:00000000 matrix_key_count
                            *COM*:00000002 keymap_config

UNDEFINED SYMBOLS
mcp23018_status
i2c_start
i2c_write
i2c_stop
init_mcp23018
xputs
ergodox_blink_all_leds
debug_config
__xprintf
i2c_readNak
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
